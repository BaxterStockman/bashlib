#!/bin/bash

# Declare with -g in case we're being sourced
declare -ga BASHLIBSRC=(
    "${HOME+"${HOME}/.@bashlib_basename@.d"}"
    @otherlibdirs@
    @libdir@/@bashlib_basename@
)

declare -gA BASHLIBINC=()

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
require () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# require BASH_MODULE
#
# A wrapper around the 'source' builtin that supports a Perlish approach to
# creating libraries of shell scripts.
#
# Environment variables:
#   BASHLIB
#       A colon-separated list of filesystem paths in the style of PATH.  These
#       directories will be searched for files matching the BASH_MODULE
#       argument, in essentially the same form that perl searches @INC for .pm
#       files.
#   BASHLIBEXT
#       A file extension.  Default value is '.@bashlibext@'.
#   BASHLIBTAINT
#       When true, 'require' does not search for files in '.'.
#
# Arguments:
#   BASH_MODULE
#       A string representing either (1) a filename or (2) a module name of the
#       form 'my::shell::module'.  In the latter case, 'require' translates the
#       module name to a filename of the form "my/shell/module${BASHLIBEXT}".
#
# Exit Codes:
#   0   success
#   1   catchall
#   2   error in arguments
#   3   error sourcing file
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local maybe_mod_name="$1"

    if [[ -z "$maybe_mod_name" ]]; then
        printf 'You must provide a module name or file name\n' 1>&2
        return 2
    fi

    local ext="${BASHLIBEXT:-@bashlibext@}"

    # We determine whether maybe_mod_name holds a filename, or whether we need
    # to translate it to a filename.
    local filename
    if [[ "$maybe_mod_name" =~ \.$ext ]]; then
        filename="$maybe_mod_name"
    else
        # Replace all instances of '::' in maybe_mod_name with '/', then append
        # the filename extension.
        local filename_prefix="${maybe_mod_name//:://}"
        filename="${filename_prefix}.${ext}"
    fi

    local -a libdirs
    read -r -a libdirs <<<$(bashlibsrc)

    # can_require contains 'false' if the library file couldn't be found in ANY
    # of the libdirs, 'true' otherwise
    local fq_filename
    for libdir in "${libdirs[@]}"; do
        fq_filename="${libdir}/${filename}"
        if [[ -f "$fq_filename" ]]; then
            # Allow 'source' to fail and print a diagnostic message.  This is
            # useful when the file exists but isn't readable.
            if source "$fq_filename"; then
                BASHLIBINC["$filename"]="$fq_filename"
                return 0
                break
            fi
        fi
    done

    printf 1>&2 "Can't locate '%s' in BASHLIBSRC (BASHLIBSRC contains: %s)\n" \
        "$filename" \
        "${libdirs[*]}"

    return 1
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
bashlibinc () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local -a filenames

    if (( $# )); then
        filenames=("$@")
    else
        filenames=("${!BASHLIBINC[@]}")
    fi

    local -i longest_filename_len=0
    local -i filename_len
    for filename in "${filenames[@]}"; do
        filename_len=${#filename}
        if (( filename_len > longest_filename_len )); then
            longest_filename_len=$filename_len
        fi
    done

    local format="%-${longest_filename_len}s %-s\n"

    for filename in "${filenames[@]}"; do
        printf "$format" "$filename" "${BASHLIBINC["$filename"]:-}"
    done
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
bashlibsrc () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local -a bashlibdirs=()
    IFS=$':' read -ra bashlibdirs <<<"$BASHLIB"

    local dir=''
    if [[ "$BASHLIBTAINT" == true ]] && [[ "$BASHLIBTAINT" -eq 1 ]]; then
        for dir in "${bashlibdirs[@]}" "${BASHLIBSRC[@]}"; do
            [[ $dir != . ]] && echo "$dir"
        done
    else
        for dir in "${bashlibdirs[@]}" "${BASHLIBSRC[@]}" '.'; do
            echo "$dir"
        done
    fi
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
bashlibusage () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    echo 'Usage: bashlib [--source] [-L|--add-lib LIBPATH] [-h|--help]'
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
bashlibhelp () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    printf '%s' "\

"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
bashlibmain () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if ! (( $# )); then
        bashlibusage
        exit 1
    fi

    local -i do_source=0
    while (( $# )); do
        read -r opt_name opt_arg _ <<<"$@"
        case "$opt_name" in
            -L|--add-lib)
                BASHLIBSRC=("$opt_arg" "${BASHLIBSRC[@]}")
                shift 2
                ;;
            -s|--source)
                do_source=1
                shift
                ;;
            -h|--help)
                bashlibhelp
                return 1
                ;;
            *)
                echo "Unrecognized option: ${opt_name}" 1>&2
                exit 1
                ;;
        esac
    done

    if (( do_source )); then
        local -a evallines=(
            "source ${BASH_SOURCE[0]}"
            "$(declare -p BASHLIBSRC)"
            "$(declare -p BASHLIBINC)"
        )
        printf '%s ;\n' "${evallines[@]}"
        return 0
    fi
}

if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
    bashlibmain "$@"
else
    unset -f bashlibusage bashlibmain
fi
